{"title":"Sandboxie注入","date":"2019-11-21T05:44:57.000Z","source":"_posts/Sandboxie 注入流程.md","raw":"---\ntitle: Sandboxie注入\ndate: 2019-11-21 13:44:57\n\ncategories:\n  - Windows\ntags: \n  - Sandbox\n---\nSandboxie 注入流程的一个整体梳理，帮助理解它是如何将自身的代码（SbieDll.dll）注入目标进程，并在进程启动或执行过程中完成一系列钩子和初始化操作的。\n\n## 1. 注入触发与初始流程  \n\n1. 进程创建通知  \n   - Sandboxie 驱动通过 PsSetCreateProcessNotifyRoutine 回调获得进程创建的通知。  \n   - 如果判断该进程需要被沙箱化，就会阻塞创建流程，并让服务进程（SbieSvc）执行后续的注入（或者先创建挂起的进程，再通过驱动进行沙箱化注入）。\n\n2. 核心函数：SbieDll_InjectLow  \n   - 这是执行远程注入的主要函数：_FX ULONG SbieDll_InjectLow(HANDLE hProcess, BOOLEAN is_wow64, BOOLEAN bHostInject, BOOLEAN dup_drv_handle)  \n   - 其参数包括：目标进程句柄 hProcess、进程是否 WoW64（is_wow64）、是否以特殊模式注入（bHostInject）、以及是否需要将驱动句柄也一起传递（dup_drv_handle）等。\n\n3. 准备低级数据结构（SBIELOW_DATA）  \n   - 在注入之前，会先创建名为 lowdata 的数据结构（SBIELOW_DATA），并在其中存储进程/注入相关的各种标志和参数：  \n     - is_wow64  \n     - bHostInject  \n     - api_device_handle（可选）  \n     - … 等，用于后续在目标进程中使用。\n\n---\n\n## 2. Shell Code（LowLevel.dll）的分配与写入\n\n1. 分配并写入 Shell Code  \n   - 调用 SbieDll_InjectLow_CopyCode 在目标进程中分配一段内存，保留给整个 shell code（LowLevel.dll）和它的跳转表（SBIELOW_J_TABLE），并将资源里的 shell code 内容直接写入到目标进程。  \n   - 然后还会拷贝一些 ntdll!LdrInitializeThunk 的前 48 个字节到 lowdata.LdrInitializeThunk_tramp（稍后会构造跳板用）。\n\n2. 可选：复制驱动句柄  \n   - 若 dup_drv_handle 参数为真，会调用 SbieDll_InjectLow_SendHandle 将驱动句柄复制给目标进程，并写入该句柄到 lowdata.api_device_handle。\n\n3. 保存各项地址 / 函数  \n   - 将进一步需要的 ntdll 函数地址、SBIELOW_J_TABLE 的地址等写入到注入数据块里 (lowdata 中)。\n\n4. 构造入口跳板  \n   - SbieDll_InjectLow_BuildTramp 在 LdrInitializeThunk_tramp 中建立一个跳板，用于将后续流程跳回到原先的 LdrInitializeThunk。\n\n5. 分配并写入 syscall 数据  \n   - SbieDll_InjectLow_CopySyscalls 再分配一段内存存放 “系统调用 hooking” 所需的元数据（syscall_data），并整合一些对 SBIELOW_EXTRA_DATA 的引用。  \n   - 其中包含了要注入的 SbieDll.dll 路径（32/64 位版本），以及部分加载信息。最后将 lowdata.syscall_data 与这块内存关联。\n\n6. 覆盖 ntdll!LdrInitializeThunk  \n   - 最后一步，调用 SbieDll_InjectLow_WriteJump 修改目标进程的 ntdll!LdrInitializeThunk（前几个字节）为跳转指令，指向写入进程内存中的 shell code 起始位置。\n\n结果：目标进程一旦恢复执行（Resume），它首先会执行被覆盖的 LdrInitializeThunk，从而跳进 shell code（LowLevel.dll）的入口点。\n\n---\n\n## 3. Shell Code（LowLevel.dll）的执行\n\n1. Shell Code 入口：_Start  \n   - shell code 安装在进程内存后，代码默认基地址为 0（以形成位置无关）。  \n   - _Start 会计算出自己（shell code）在目标进程中的真实基地址，然后推算出写入的数据块指针（SBIELOW_DATA）和一批帮助函数的地址。  \n   - 最后它调用 EntrypointC 进入 C 语言部分。\n\n2. EntrypointC 主流程  \n   - 通过自旋锁防止重复执行。  \n   - 判断 data->bHostInject：  \n     - 若等于 0：调用 InitSyscalls 钩住所有 ntdll syscall，再调用 InitInject 做 DLL 注入准备，并在 64 位时进一步修改 ConsoleHandle。  \n     - 若不为 0：只调用 InitInject。  \n   - 最后，它跳转回原先保存在 data->LdrInitializeThunk_tramp（即最开始备份的 LdrInitializeThunk)。\n\n---\n\n## 4. InitInject 与 RtlFindActivationContextSectionString 钩子\n\n1. 查找目标 ntdll 基址  \n   - 判断是原生 32 位/64 位进程，还是 wow64 环境。  \n   - 在 wow64 情况下，需要找到 32 位 ntdll 基址。Windows 8 之后不能直接使用 KUSER_SHARED_DATA::Wow64SharedInformation，故 Sandboxie 使用 NtQueryVirtualMemory 获取并保存在 ntdll_wow64_base 字段。\n\n2. 转换 syscall_data 内存为 INJECT_DATA  \n   - 在注入数据区（syscall_data）内部的一部分空间会临时用作 INJECT_DATA 结构，存放加载 DLL 所需的地址及路径、钩子信息等。\n\n3. 定位并钩住 RtlFindActivationContextSectionString  \n   - 解析 ntdll 导出表，找到 LdrLoadDll, LdrGetProcedureAddress, NtRaiseHardError 以及 RtlFindActivationContextSectionString 等地址。  \n   - 在 64 位或 32 位 ntdll 中，通过保存原函数开头若干字节，再使用跳转指令将 RtlFindActivationContextSectionString 的入口改写为 Sandboxie 的 detour 函数。\n\n4. RtlFindActivationContextSectionString Detour  \n   - 该 detour 会先还原 RtlFindActivationContextSectionString 的开头，然后加载 kernel32.dll、再加载 SbieDll.dll，并调用 SbieDll!Dll_Ordinal1（导出序号 1）。  \n   - 注意：因为这个 detour 在目标进程的同一位宽模式下执行（即 64 位进程为 64 位指令，wow64 进程为 32 位指令）。\n\n---\n\n## 5. SbieDll.dll 的执行\n\n1. Dll_Ordinal1  \n   - 这是注入的主要入口函数；它读取传进来的 INJECT_DATA，获取 SBIELOW_DATA 的地址等关键信息。  \n   - 然后释放早先的那块 INJECT_DATA（不再需要）。  \n   - 依据 bHostInject:  \n     - 若 = 0：调用 SbieDll!Dll_InitInjected，执行各种 API 的 hooking，最后调用 SbieDll!Ldr_Init，它会设置 DLL 加载回调、再调用 SbieDll!Ldr_Inject_Init 等进行更多注入操作。  \n     - 若 != 0：直接调用 SbieDll!Ldr_Inject_Init。  \n   - 完成后，再执行原 RtlFindActivationContextSectionString（还原之前 detour 修改的参数），并返回给调用者。\n\n2. 进程主入口点的二次钩子  \n   - SbieDll!Ldr_Inject_Init 再次设置一个钩子，这次目标是可执行文件的真实 Entry Point：  \n     - 备份该入口点头几个字节，并改写为 jump 指令，引向 SbieDll!Ldr_Inject_Entry64 或 SbieDll!Ldr_Inject_Entry32。  \n   - 这样一来，目标进程运行到真正的入口点时，也会经过 SbieDll 代码进行最后阶段初始化。\n\n3. Ldr_Inject_Entry  \n   - 恢复原入口点指令，并让返回地址指向入口点开头（使后续仍能正常执行程序原代码）。  \n   - 如果 bHostInject = 0，在真正执行进程的入口点前，还会调用 SbieDll!Ldr_LoadInjectDlls 加载 Sandboxie.ini 配置的额外 DLL，然后再执行 SbieDll!Dll_InitExeEntry 做最后的注入初始化。  \n   - 若 bHostInject != 0，只执行 SbieDll!Ldr_LoadInjectDlls。  \n   - 完毕后返回到目标进程真正入口点，让应用程序继续正常运行。\n\n---\n\n## 小结\n\n1. 主要组件  \n   - Loader/Injector：由服务或驱动调用 SbieDll_InjectLow，将 shell code（LowLevel.dll）及其配套数据写入目标进程，改写 ntdll!LdrInitializeThunk 以便在进程启动时接管流程。  \n   - Shell Code (LowLevel.dll)：进程开始执行后，首先进入该 shell code；它会根据场景完成提权、设置钩子等需求，然后跳回系统原生入口函数。  \n   - Payload (SbieDll.dll)：shell code 载入完 SbieDll.dll 并调用其导出函数 Dll_Ordinal1，这才是 Sandboxie 真正的“核心注入逻辑”，进一步对系统 API、进程入口点进行钩子或劫持，实现对目标进程的沙箱化控制。\n\n2. 多层“hooking”  \n   - 首先劫持 OS 的进程启动例程（LdrInitializeThunk），再劫持 RtlFindActivationContextSectionString 来加载自己的核心 DLL，随后还要在进程入口点加一层钩子，都旨在保证 Sandboxie 的注入逻辑在最早和最关键的时机介入。\n\n3. 32/64 位兼容  \n   - 在 64 位系统上针对 WoW64 进程，会在 shell code 或后续流程里专门定位 32 位 ntdll，并通过相应的调用和汇编跳转来实现注入。这使得 Sandboxie 可以同时处理原生 x64 和 WoW64 子系统的进程。\n\n整体而言，Sandboxie 的 DLL 注入流程高度依赖对底层 Windows 内核对象（进程、Section、ntdll 函数等）的操作以及对关键启动例程的修改，分层递进地实现对目标进程的控制和后续所有加载行为的监控或拦截。","slug":"Sandboxie 注入流程","published":true,"updated":"2025-07-07T06:24:56.192Z","_id":"cmcsr1syr0000qkktbr15apa0","comments":true,"layout":"post","photos":[],"html":"<p>Sandboxie 注入流程的一个整体梳理，帮助理解它是如何将自身的代码（SbieDll.dll）注入目标进程，并在进程启动或执行过程中完成一系列钩子和初始化操作的。</p>\n<h2 id=\"1-注入触发与初始流程\"><a href=\"#1-注入触发与初始流程\" class=\"headerlink\" title=\"1. 注入触发与初始流程\"></a>1. 注入触发与初始流程</h2><ol>\n<li><p>进程创建通知  </p>\n<ul>\n<li>Sandboxie 驱动通过 PsSetCreateProcessNotifyRoutine 回调获得进程创建的通知。  </li>\n<li>如果判断该进程需要被沙箱化，就会阻塞创建流程，并让服务进程（SbieSvc）执行后续的注入（或者先创建挂起的进程，再通过驱动进行沙箱化注入）。</li>\n</ul>\n</li>\n<li><p>核心函数：SbieDll_InjectLow  </p>\n<ul>\n<li>这是执行远程注入的主要函数：_FX ULONG SbieDll_InjectLow(HANDLE hProcess, BOOLEAN is_wow64, BOOLEAN bHostInject, BOOLEAN dup_drv_handle)  </li>\n<li>其参数包括：目标进程句柄 hProcess、进程是否 WoW64（is_wow64）、是否以特殊模式注入（bHostInject）、以及是否需要将驱动句柄也一起传递（dup_drv_handle）等。</li>\n</ul>\n</li>\n<li><p>准备低级数据结构（SBIELOW_DATA）  </p>\n<ul>\n<li>在注入之前，会先创建名为 lowdata 的数据结构（SBIELOW_DATA），并在其中存储进程&#x2F;注入相关的各种标志和参数：  <ul>\n<li>is_wow64  </li>\n<li>bHostInject  </li>\n<li>api_device_handle（可选）  </li>\n<li>… 等，用于后续在目标进程中使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"2-Shell-Code（LowLevel-dll）的分配与写入\"><a href=\"#2-Shell-Code（LowLevel-dll）的分配与写入\" class=\"headerlink\" title=\"2. Shell Code（LowLevel.dll）的分配与写入\"></a>2. Shell Code（LowLevel.dll）的分配与写入</h2><ol>\n<li><p>分配并写入 Shell Code  </p>\n<ul>\n<li>调用 SbieDll_InjectLow_CopyCode 在目标进程中分配一段内存，保留给整个 shell code（LowLevel.dll）和它的跳转表（SBIELOW_J_TABLE），并将资源里的 shell code 内容直接写入到目标进程。  </li>\n<li>然后还会拷贝一些 ntdll!LdrInitializeThunk 的前 48 个字节到 lowdata.LdrInitializeThunk_tramp（稍后会构造跳板用）。</li>\n</ul>\n</li>\n<li><p>可选：复制驱动句柄  </p>\n<ul>\n<li>若 dup_drv_handle 参数为真，会调用 SbieDll_InjectLow_SendHandle 将驱动句柄复制给目标进程，并写入该句柄到 lowdata.api_device_handle。</li>\n</ul>\n</li>\n<li><p>保存各项地址 &#x2F; 函数  </p>\n<ul>\n<li>将进一步需要的 ntdll 函数地址、SBIELOW_J_TABLE 的地址等写入到注入数据块里 (lowdata 中)。</li>\n</ul>\n</li>\n<li><p>构造入口跳板  </p>\n<ul>\n<li>SbieDll_InjectLow_BuildTramp 在 LdrInitializeThunk_tramp 中建立一个跳板，用于将后续流程跳回到原先的 LdrInitializeThunk。</li>\n</ul>\n</li>\n<li><p>分配并写入 syscall 数据  </p>\n<ul>\n<li>SbieDll_InjectLow_CopySyscalls 再分配一段内存存放 “系统调用 hooking” 所需的元数据（syscall_data），并整合一些对 SBIELOW_EXTRA_DATA 的引用。  </li>\n<li>其中包含了要注入的 SbieDll.dll 路径（32&#x2F;64 位版本），以及部分加载信息。最后将 lowdata.syscall_data 与这块内存关联。</li>\n</ul>\n</li>\n<li><p>覆盖 ntdll!LdrInitializeThunk  </p>\n<ul>\n<li>最后一步，调用 SbieDll_InjectLow_WriteJump 修改目标进程的 ntdll!LdrInitializeThunk（前几个字节）为跳转指令，指向写入进程内存中的 shell code 起始位置。</li>\n</ul>\n</li>\n</ol>\n<p>结果：目标进程一旦恢复执行（Resume），它首先会执行被覆盖的 LdrInitializeThunk，从而跳进 shell code（LowLevel.dll）的入口点。</p>\n<hr>\n<h2 id=\"3-Shell-Code（LowLevel-dll）的执行\"><a href=\"#3-Shell-Code（LowLevel-dll）的执行\" class=\"headerlink\" title=\"3. Shell Code（LowLevel.dll）的执行\"></a>3. Shell Code（LowLevel.dll）的执行</h2><ol>\n<li><p>Shell Code 入口：_Start  </p>\n<ul>\n<li>shell code 安装在进程内存后，代码默认基地址为 0（以形成位置无关）。  </li>\n<li>_Start 会计算出自己（shell code）在目标进程中的真实基地址，然后推算出写入的数据块指针（SBIELOW_DATA）和一批帮助函数的地址。  </li>\n<li>最后它调用 EntrypointC 进入 C 语言部分。</li>\n</ul>\n</li>\n<li><p>EntrypointC 主流程  </p>\n<ul>\n<li>通过自旋锁防止重复执行。  </li>\n<li>判断 data-&gt;bHostInject：  <ul>\n<li>若等于 0：调用 InitSyscalls 钩住所有 ntdll syscall，再调用 InitInject 做 DLL 注入准备，并在 64 位时进一步修改 ConsoleHandle。  </li>\n<li>若不为 0：只调用 InitInject。</li>\n</ul>\n</li>\n<li>最后，它跳转回原先保存在 data-&gt;LdrInitializeThunk_tramp（即最开始备份的 LdrInitializeThunk)。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-InitInject-与-RtlFindActivationContextSectionString-钩子\"><a href=\"#4-InitInject-与-RtlFindActivationContextSectionString-钩子\" class=\"headerlink\" title=\"4. InitInject 与 RtlFindActivationContextSectionString 钩子\"></a>4. InitInject 与 RtlFindActivationContextSectionString 钩子</h2><ol>\n<li><p>查找目标 ntdll 基址  </p>\n<ul>\n<li>判断是原生 32 位&#x2F;64 位进程，还是 wow64 环境。  </li>\n<li>在 wow64 情况下，需要找到 32 位 ntdll 基址。Windows 8 之后不能直接使用 KUSER_SHARED_DATA::Wow64SharedInformation，故 Sandboxie 使用 NtQueryVirtualMemory 获取并保存在 ntdll_wow64_base 字段。</li>\n</ul>\n</li>\n<li><p>转换 syscall_data 内存为 INJECT_DATA  </p>\n<ul>\n<li>在注入数据区（syscall_data）内部的一部分空间会临时用作 INJECT_DATA 结构，存放加载 DLL 所需的地址及路径、钩子信息等。</li>\n</ul>\n</li>\n<li><p>定位并钩住 RtlFindActivationContextSectionString  </p>\n<ul>\n<li>解析 ntdll 导出表，找到 LdrLoadDll, LdrGetProcedureAddress, NtRaiseHardError 以及 RtlFindActivationContextSectionString 等地址。  </li>\n<li>在 64 位或 32 位 ntdll 中，通过保存原函数开头若干字节，再使用跳转指令将 RtlFindActivationContextSectionString 的入口改写为 Sandboxie 的 detour 函数。</li>\n</ul>\n</li>\n<li><p>RtlFindActivationContextSectionString Detour  </p>\n<ul>\n<li>该 detour 会先还原 RtlFindActivationContextSectionString 的开头，然后加载 kernel32.dll、再加载 SbieDll.dll，并调用 SbieDll!Dll_Ordinal1（导出序号 1）。  </li>\n<li>注意：因为这个 detour 在目标进程的同一位宽模式下执行（即 64 位进程为 64 位指令，wow64 进程为 32 位指令）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"5-SbieDll-dll-的执行\"><a href=\"#5-SbieDll-dll-的执行\" class=\"headerlink\" title=\"5. SbieDll.dll 的执行\"></a>5. SbieDll.dll 的执行</h2><ol>\n<li><p>Dll_Ordinal1  </p>\n<ul>\n<li>这是注入的主要入口函数；它读取传进来的 INJECT_DATA，获取 SBIELOW_DATA 的地址等关键信息。  </li>\n<li>然后释放早先的那块 INJECT_DATA（不再需要）。  </li>\n<li>依据 bHostInject:  <ul>\n<li>若 &#x3D; 0：调用 SbieDll!Dll_InitInjected，执行各种 API 的 hooking，最后调用 SbieDll!Ldr_Init，它会设置 DLL 加载回调、再调用 SbieDll!Ldr_Inject_Init 等进行更多注入操作。  </li>\n<li>若 !&#x3D; 0：直接调用 SbieDll!Ldr_Inject_Init。</li>\n</ul>\n</li>\n<li>完成后，再执行原 RtlFindActivationContextSectionString（还原之前 detour 修改的参数），并返回给调用者。</li>\n</ul>\n</li>\n<li><p>进程主入口点的二次钩子  </p>\n<ul>\n<li>SbieDll!Ldr_Inject_Init 再次设置一个钩子，这次目标是可执行文件的真实 Entry Point：  <ul>\n<li>备份该入口点头几个字节，并改写为 jump 指令，引向 SbieDll!Ldr_Inject_Entry64 或 SbieDll!Ldr_Inject_Entry32。</li>\n</ul>\n</li>\n<li>这样一来，目标进程运行到真正的入口点时，也会经过 SbieDll 代码进行最后阶段初始化。</li>\n</ul>\n</li>\n<li><p>Ldr_Inject_Entry  </p>\n<ul>\n<li>恢复原入口点指令，并让返回地址指向入口点开头（使后续仍能正常执行程序原代码）。  </li>\n<li>如果 bHostInject &#x3D; 0，在真正执行进程的入口点前，还会调用 SbieDll!Ldr_LoadInjectDlls 加载 Sandboxie.ini 配置的额外 DLL，然后再执行 SbieDll!Dll_InitExeEntry 做最后的注入初始化。  </li>\n<li>若 bHostInject !&#x3D; 0，只执行 SbieDll!Ldr_LoadInjectDlls。  </li>\n<li>完毕后返回到目标进程真正入口点，让应用程序继续正常运行。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li><p>主要组件  </p>\n<ul>\n<li>Loader&#x2F;Injector：由服务或驱动调用 SbieDll_InjectLow，将 shell code（LowLevel.dll）及其配套数据写入目标进程，改写 ntdll!LdrInitializeThunk 以便在进程启动时接管流程。  </li>\n<li>Shell Code (LowLevel.dll)：进程开始执行后，首先进入该 shell code；它会根据场景完成提权、设置钩子等需求，然后跳回系统原生入口函数。  </li>\n<li>Payload (SbieDll.dll)：shell code 载入完 SbieDll.dll 并调用其导出函数 Dll_Ordinal1，这才是 Sandboxie 真正的“核心注入逻辑”，进一步对系统 API、进程入口点进行钩子或劫持，实现对目标进程的沙箱化控制。</li>\n</ul>\n</li>\n<li><p>多层“hooking”  </p>\n<ul>\n<li>首先劫持 OS 的进程启动例程（LdrInitializeThunk），再劫持 RtlFindActivationContextSectionString 来加载自己的核心 DLL，随后还要在进程入口点加一层钩子，都旨在保证 Sandboxie 的注入逻辑在最早和最关键的时机介入。</li>\n</ul>\n</li>\n<li><p>32&#x2F;64 位兼容  </p>\n<ul>\n<li>在 64 位系统上针对 WoW64 进程，会在 shell code 或后续流程里专门定位 32 位 ntdll，并通过相应的调用和汇编跳转来实现注入。这使得 Sandboxie 可以同时处理原生 x64 和 WoW64 子系统的进程。</li>\n</ul>\n</li>\n</ol>\n<p>整体而言，Sandboxie 的 DLL 注入流程高度依赖对底层 Windows 内核对象（进程、Section、ntdll 函数等）的操作以及对关键启动例程的修改，分层递进地实现对目标进程的控制和后续所有加载行为的监控或拦截。</p>\n","excerpt":"","more":"<p>Sandboxie 注入流程的一个整体梳理，帮助理解它是如何将自身的代码（SbieDll.dll）注入目标进程，并在进程启动或执行过程中完成一系列钩子和初始化操作的。</p>\n<h2 id=\"1-注入触发与初始流程\"><a href=\"#1-注入触发与初始流程\" class=\"headerlink\" title=\"1. 注入触发与初始流程\"></a>1. 注入触发与初始流程</h2><ol>\n<li><p>进程创建通知  </p>\n<ul>\n<li>Sandboxie 驱动通过 PsSetCreateProcessNotifyRoutine 回调获得进程创建的通知。  </li>\n<li>如果判断该进程需要被沙箱化，就会阻塞创建流程，并让服务进程（SbieSvc）执行后续的注入（或者先创建挂起的进程，再通过驱动进行沙箱化注入）。</li>\n</ul>\n</li>\n<li><p>核心函数：SbieDll_InjectLow  </p>\n<ul>\n<li>这是执行远程注入的主要函数：_FX ULONG SbieDll_InjectLow(HANDLE hProcess, BOOLEAN is_wow64, BOOLEAN bHostInject, BOOLEAN dup_drv_handle)  </li>\n<li>其参数包括：目标进程句柄 hProcess、进程是否 WoW64（is_wow64）、是否以特殊模式注入（bHostInject）、以及是否需要将驱动句柄也一起传递（dup_drv_handle）等。</li>\n</ul>\n</li>\n<li><p>准备低级数据结构（SBIELOW_DATA）  </p>\n<ul>\n<li>在注入之前，会先创建名为 lowdata 的数据结构（SBIELOW_DATA），并在其中存储进程&#x2F;注入相关的各种标志和参数：  <ul>\n<li>is_wow64  </li>\n<li>bHostInject  </li>\n<li>api_device_handle（可选）  </li>\n<li>… 等，用于后续在目标进程中使用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"2-Shell-Code（LowLevel-dll）的分配与写入\"><a href=\"#2-Shell-Code（LowLevel-dll）的分配与写入\" class=\"headerlink\" title=\"2. Shell Code（LowLevel.dll）的分配与写入\"></a>2. Shell Code（LowLevel.dll）的分配与写入</h2><ol>\n<li><p>分配并写入 Shell Code  </p>\n<ul>\n<li>调用 SbieDll_InjectLow_CopyCode 在目标进程中分配一段内存，保留给整个 shell code（LowLevel.dll）和它的跳转表（SBIELOW_J_TABLE），并将资源里的 shell code 内容直接写入到目标进程。  </li>\n<li>然后还会拷贝一些 ntdll!LdrInitializeThunk 的前 48 个字节到 lowdata.LdrInitializeThunk_tramp（稍后会构造跳板用）。</li>\n</ul>\n</li>\n<li><p>可选：复制驱动句柄  </p>\n<ul>\n<li>若 dup_drv_handle 参数为真，会调用 SbieDll_InjectLow_SendHandle 将驱动句柄复制给目标进程，并写入该句柄到 lowdata.api_device_handle。</li>\n</ul>\n</li>\n<li><p>保存各项地址 &#x2F; 函数  </p>\n<ul>\n<li>将进一步需要的 ntdll 函数地址、SBIELOW_J_TABLE 的地址等写入到注入数据块里 (lowdata 中)。</li>\n</ul>\n</li>\n<li><p>构造入口跳板  </p>\n<ul>\n<li>SbieDll_InjectLow_BuildTramp 在 LdrInitializeThunk_tramp 中建立一个跳板，用于将后续流程跳回到原先的 LdrInitializeThunk。</li>\n</ul>\n</li>\n<li><p>分配并写入 syscall 数据  </p>\n<ul>\n<li>SbieDll_InjectLow_CopySyscalls 再分配一段内存存放 “系统调用 hooking” 所需的元数据（syscall_data），并整合一些对 SBIELOW_EXTRA_DATA 的引用。  </li>\n<li>其中包含了要注入的 SbieDll.dll 路径（32&#x2F;64 位版本），以及部分加载信息。最后将 lowdata.syscall_data 与这块内存关联。</li>\n</ul>\n</li>\n<li><p>覆盖 ntdll!LdrInitializeThunk  </p>\n<ul>\n<li>最后一步，调用 SbieDll_InjectLow_WriteJump 修改目标进程的 ntdll!LdrInitializeThunk（前几个字节）为跳转指令，指向写入进程内存中的 shell code 起始位置。</li>\n</ul>\n</li>\n</ol>\n<p>结果：目标进程一旦恢复执行（Resume），它首先会执行被覆盖的 LdrInitializeThunk，从而跳进 shell code（LowLevel.dll）的入口点。</p>\n<hr>\n<h2 id=\"3-Shell-Code（LowLevel-dll）的执行\"><a href=\"#3-Shell-Code（LowLevel-dll）的执行\" class=\"headerlink\" title=\"3. Shell Code（LowLevel.dll）的执行\"></a>3. Shell Code（LowLevel.dll）的执行</h2><ol>\n<li><p>Shell Code 入口：_Start  </p>\n<ul>\n<li>shell code 安装在进程内存后，代码默认基地址为 0（以形成位置无关）。  </li>\n<li>_Start 会计算出自己（shell code）在目标进程中的真实基地址，然后推算出写入的数据块指针（SBIELOW_DATA）和一批帮助函数的地址。  </li>\n<li>最后它调用 EntrypointC 进入 C 语言部分。</li>\n</ul>\n</li>\n<li><p>EntrypointC 主流程  </p>\n<ul>\n<li>通过自旋锁防止重复执行。  </li>\n<li>判断 data-&gt;bHostInject：  <ul>\n<li>若等于 0：调用 InitSyscalls 钩住所有 ntdll syscall，再调用 InitInject 做 DLL 注入准备，并在 64 位时进一步修改 ConsoleHandle。  </li>\n<li>若不为 0：只调用 InitInject。</li>\n</ul>\n</li>\n<li>最后，它跳转回原先保存在 data-&gt;LdrInitializeThunk_tramp（即最开始备份的 LdrInitializeThunk)。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-InitInject-与-RtlFindActivationContextSectionString-钩子\"><a href=\"#4-InitInject-与-RtlFindActivationContextSectionString-钩子\" class=\"headerlink\" title=\"4. InitInject 与 RtlFindActivationContextSectionString 钩子\"></a>4. InitInject 与 RtlFindActivationContextSectionString 钩子</h2><ol>\n<li><p>查找目标 ntdll 基址  </p>\n<ul>\n<li>判断是原生 32 位&#x2F;64 位进程，还是 wow64 环境。  </li>\n<li>在 wow64 情况下，需要找到 32 位 ntdll 基址。Windows 8 之后不能直接使用 KUSER_SHARED_DATA::Wow64SharedInformation，故 Sandboxie 使用 NtQueryVirtualMemory 获取并保存在 ntdll_wow64_base 字段。</li>\n</ul>\n</li>\n<li><p>转换 syscall_data 内存为 INJECT_DATA  </p>\n<ul>\n<li>在注入数据区（syscall_data）内部的一部分空间会临时用作 INJECT_DATA 结构，存放加载 DLL 所需的地址及路径、钩子信息等。</li>\n</ul>\n</li>\n<li><p>定位并钩住 RtlFindActivationContextSectionString  </p>\n<ul>\n<li>解析 ntdll 导出表，找到 LdrLoadDll, LdrGetProcedureAddress, NtRaiseHardError 以及 RtlFindActivationContextSectionString 等地址。  </li>\n<li>在 64 位或 32 位 ntdll 中，通过保存原函数开头若干字节，再使用跳转指令将 RtlFindActivationContextSectionString 的入口改写为 Sandboxie 的 detour 函数。</li>\n</ul>\n</li>\n<li><p>RtlFindActivationContextSectionString Detour  </p>\n<ul>\n<li>该 detour 会先还原 RtlFindActivationContextSectionString 的开头，然后加载 kernel32.dll、再加载 SbieDll.dll，并调用 SbieDll!Dll_Ordinal1（导出序号 1）。  </li>\n<li>注意：因为这个 detour 在目标进程的同一位宽模式下执行（即 64 位进程为 64 位指令，wow64 进程为 32 位指令）。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"5-SbieDll-dll-的执行\"><a href=\"#5-SbieDll-dll-的执行\" class=\"headerlink\" title=\"5. SbieDll.dll 的执行\"></a>5. SbieDll.dll 的执行</h2><ol>\n<li><p>Dll_Ordinal1  </p>\n<ul>\n<li>这是注入的主要入口函数；它读取传进来的 INJECT_DATA，获取 SBIELOW_DATA 的地址等关键信息。  </li>\n<li>然后释放早先的那块 INJECT_DATA（不再需要）。  </li>\n<li>依据 bHostInject:  <ul>\n<li>若 &#x3D; 0：调用 SbieDll!Dll_InitInjected，执行各种 API 的 hooking，最后调用 SbieDll!Ldr_Init，它会设置 DLL 加载回调、再调用 SbieDll!Ldr_Inject_Init 等进行更多注入操作。  </li>\n<li>若 !&#x3D; 0：直接调用 SbieDll!Ldr_Inject_Init。</li>\n</ul>\n</li>\n<li>完成后，再执行原 RtlFindActivationContextSectionString（还原之前 detour 修改的参数），并返回给调用者。</li>\n</ul>\n</li>\n<li><p>进程主入口点的二次钩子  </p>\n<ul>\n<li>SbieDll!Ldr_Inject_Init 再次设置一个钩子，这次目标是可执行文件的真实 Entry Point：  <ul>\n<li>备份该入口点头几个字节，并改写为 jump 指令，引向 SbieDll!Ldr_Inject_Entry64 或 SbieDll!Ldr_Inject_Entry32。</li>\n</ul>\n</li>\n<li>这样一来，目标进程运行到真正的入口点时，也会经过 SbieDll 代码进行最后阶段初始化。</li>\n</ul>\n</li>\n<li><p>Ldr_Inject_Entry  </p>\n<ul>\n<li>恢复原入口点指令，并让返回地址指向入口点开头（使后续仍能正常执行程序原代码）。  </li>\n<li>如果 bHostInject &#x3D; 0，在真正执行进程的入口点前，还会调用 SbieDll!Ldr_LoadInjectDlls 加载 Sandboxie.ini 配置的额外 DLL，然后再执行 SbieDll!Dll_InitExeEntry 做最后的注入初始化。  </li>\n<li>若 bHostInject !&#x3D; 0，只执行 SbieDll!Ldr_LoadInjectDlls。  </li>\n<li>完毕后返回到目标进程真正入口点，让应用程序继续正常运行。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li><p>主要组件  </p>\n<ul>\n<li>Loader&#x2F;Injector：由服务或驱动调用 SbieDll_InjectLow，将 shell code（LowLevel.dll）及其配套数据写入目标进程，改写 ntdll!LdrInitializeThunk 以便在进程启动时接管流程。  </li>\n<li>Shell Code (LowLevel.dll)：进程开始执行后，首先进入该 shell code；它会根据场景完成提权、设置钩子等需求，然后跳回系统原生入口函数。  </li>\n<li>Payload (SbieDll.dll)：shell code 载入完 SbieDll.dll 并调用其导出函数 Dll_Ordinal1，这才是 Sandboxie 真正的“核心注入逻辑”，进一步对系统 API、进程入口点进行钩子或劫持，实现对目标进程的沙箱化控制。</li>\n</ul>\n</li>\n<li><p>多层“hooking”  </p>\n<ul>\n<li>首先劫持 OS 的进程启动例程（LdrInitializeThunk），再劫持 RtlFindActivationContextSectionString 来加载自己的核心 DLL，随后还要在进程入口点加一层钩子，都旨在保证 Sandboxie 的注入逻辑在最早和最关键的时机介入。</li>\n</ul>\n</li>\n<li><p>32&#x2F;64 位兼容  </p>\n<ul>\n<li>在 64 位系统上针对 WoW64 进程，会在 shell code 或后续流程里专门定位 32 位 ntdll，并通过相应的调用和汇编跳转来实现注入。这使得 Sandboxie 可以同时处理原生 x64 和 WoW64 子系统的进程。</li>\n</ul>\n</li>\n</ol>\n<p>整体而言，Sandboxie 的 DLL 注入流程高度依赖对底层 Windows 内核对象（进程、Section、ntdll 函数等）的操作以及对关键启动例程的修改，分层递进地实现对目标进程的控制和后续所有加载行为的监控或拦截。</p>\n","path":"2019/11/21/Sandboxie 注入流程/","permalink":"http://example.com/2019/11/21/Sandboxie%20%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B/","tags":[{"name":"Sandbox","_id":"cmcsr1syx0003qkktb2v9diis","slug":"Sandbox","path":"tags/Sandbox/","permalink":"http://example.com/tags/Sandbox/","length":1}],"categories":[{"name":"Windows","_id":"cmcsr1syw0002qkkt7q9u2td5","slug":"Windows","path":"categories/Windows/","permalink":"http://example.com/categories/Windows/","length":1}],"prev":{"title":"Hello World","date":"2025-07-04T10:30:41.153Z","slug":"hello-world","published":true,"updated":"2025-07-04T10:30:41.153Z","_id":"cmcsr1syu0001qkkte1aphyiv","layout":"post","photos":[],"excerpt":"","path":"2025/07/04/hello-world/","permalink":"http://example.com/2025/07/04/hello-world/","__post":true},"next":null,"__post":true}